{
    "collab_server" : "",
    "contents" : "#' Obtain the standard error of the mean\n#'\n#' @param x a numeric vector\n#' @param na.rm a logical value indicating whether NA values should be stripped before the computation proceeds.\n#'\n#' @return a scalar equal to the standard error of the mean, computed as sd(x)/(sqrt(n)).\n#' @export\n#'\n#' @examples\n#'\n#' x <- rnorm(100)\n#' mean(x)\n#' se_mean(x)\n#'\n#'\nse_mean <- function(x, na.rm = FALSE){\n  # Error handling from mean.default\n  if (!is.numeric(x) && !is.complex(x) && !is.logical(x)) {\n    warning(\"argument is not numeric or logical: returning NA\")\n    return(NA_real_)\n  }\n  if (na.rm) {x <- x[!is.na(x)]}\n  n <- length(x)\n  return(sd(x)/(sqrt(n)))\n}\n\n\n#' Title\n#'\n#' @param fit A model object, typically created by lm, glm, or many other model fitting functions.\n#' @param cluster An optional numeric vector of length N that describes the clusters that units are in. May not include NAs. Is NULL by default. If specified, cluster-robust standard errors will be estimated.\n#' @param type A string indicating the type of heterskedasticty-robust standard errors to be estimated. Is ignored if cluster is specificed. Is \"HC2\" by default, because these are equivalent to Neyman standard errors (See Aronow and Samii).\n#'\n#' @return A matrix of coefficients, standard errors, t-statistics, and p-values\n#' @export\n#'\n#' @examples\n#'\n#' library(randomizr)\n#'\n#' Y <- rnorm(100)\n#' Z <- complete_ra(100)\n#' fit <- lm(Y ~ Z)\n#' commarobust(fit)\n#'\n#' # Clustered\n#' Y <- rnorm(100)\n#' clust <- rep(letters[1:10], 10)\n#' Z <- cluster_ra(clust)\n#'\n#' fit <- lm(Y ~ Z)\n#' commarobust(fit, cluster = clust)\n#'\ncommarobust <- function(fit, cluster = NULL, type=\"HC2\"){\n  if(is.null(cluster)){\n    return_obj <- lmtest::coeftest(fit,sandwich::vcovHC(fit, type=type))[]\n  }else{\n    M <- length(unique(cluster))\n    N <- length(cluster)\n    K <- fit$rank\n    dfc <- (M/(M-1))*((N-1)/(N-K))\n    uj  <- apply(sandwich::estfun(fit),2, function(x) tapply(x, cluster, sum));\n    vcovCL <- dfc*sandwich::sandwich(fit, meat=crossprod(uj)/N)\n    return_obj <- lmtest::coeftest(fit, vcovCL)[]\n  }\n  attr(return_obj, \"method\") <- NULL\n  return(return_obj)\n}\n\n\ngetrobustses <- function(fit, type = \"HC2\"){\n  robustfit <- commarobust(fit, type = type)\n  return(robustfit[,2])\n}\n\ngetrobustps <- function(fit, type = \"HC2\"){\n  robustfit <- commarobust(fit, type = type)\n  ps <- robustfit[,4]\n  ps[\"(Intercept)\"] <- 1\n  return(ps)\n}\n\n#' Prepare Ses for Stargazer\n#'\n#' This function will prepare heteroskedasticity-robust standard errors for stargazer. Currently, it does not handle cluster-robust standard errors because there is no nice way to pass model-specific vectors of clusters.\n#'\n#' @param ... a series of model fits, separated by commas\n#' @param type A string indicating the type of heterskedasticty-robust standard errors to be estimated. Is ignored if cluster is specificed. Is \"HC2\" by default, because these are equivalent to Neyman standard errors (See Aronow and Samii).\n#'\n#' @return A list of vectors of robust standard errors.\n#' @export\n#'\n#' @examples\n#' library(randomizr)\n#' library(stargazer)\n#'\n#' Z_1 <- complete_ra(100)\n#' Y_1 <- 10 + 5*Z_1 + rnorm(100)\n#' Z_2 <- complete_ra(100)\n#' Y_2 <- 10 + 2*Z_2 + rnorm(100)\n#'\n#' fit_1 <- lm(Y_1 ~ Z_1)\n#' fit_2 <- lm(Y_2 ~ Z_2)\n#'\n#' stargazer(fit_1, fit_2,\n#'           se = makerobustseslist(fit_1, fit_2),\n#'           p = makerobustpslist(fit_1, fit_2))\n#'\nmakerobustseslist <- function(..., type = \"HC2\"){\n  fitlist = list(...)\n  return(lapply(fitlist, FUN=getrobustses, type = type) )\n}\n\n#' Prepare ps for Stargazer\n#'\n#' This function will prepare p-values for stargazer based on the robust standard errors. Stargazer will do this automatically, so the main purpose of this function is to set the p-value of the intercept to 1. In experimental research, the intercept is often the sample mean for the control group and a test of the null hypothesis that it is equal to do is silly to report.\n#'\n#' @param ... a series of model fits, separated by commas\n#' @param type A string indicating the type of heterskedasticty-robust standard errors to be estimated. Is ignored if cluster is specificed. Is \"HC2\" by default, because these are equivalent to Neyman standard errors (See Aronow and Samii).\n#'\n#' @return A list of vectors of robust standard errors.\n#' @export\n#'\n#' @examples\n#' library(randomizr)\n#' library(stargazer)\n#'\n#' Y_1 <- rnorm(100)\n#' Z_1 <- complete_ra(100)\n#' Y_2 <- rnorm(100)\n#' Z_2 <- complete_ra(100)\n#'\n#' fit_1 <- lm(Y_1 ~ Z_1)\n#' fit_2 <- lm(Y_2 ~ Z_2)\n#'\n#' stargazer(fit_1, fit_2,\n#'           se = makerobustseslist(fit_1, fit_2),\n#'           p = makerobustpslist(fit_1, fit_2))\n#'\nmakerobustpslist <- function(..., type = \"HC2\"){\n  fitlist = list(...)\n  return(lapply(fitlist, FUN=getrobustps, type = type))\n}\n",
    "created" : 1456862293168.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1950387332",
    "id" : "99E27312",
    "lastKnownWriteTime" : 1456866875,
    "last_content_update" : 1456866875318,
    "path" : "~/Documents/commarobust/R/commarobust.R",
    "project_path" : "R/commarobust.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}